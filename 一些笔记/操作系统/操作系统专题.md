# 操作系统专题

### 目录

---
<a href="#1">1. 进程间的通信方式(IPC)?进程调度方法?</a> <br>
<a href="#2">2. 线程间通信的方式?</a> <br>
<a href="#3">3. 线程同步的机制。</a> <br>
<a href="#4">4. 操作系统由哪些部分组成?</a> <br>.w
<a href="#5">5. 用户态和系统态在什么时候进行切换?X平时用的都是 64 位系统,那它和 32 位系统相比,有什么区别和优点?</a> <br>
<a href="#6">6. 选择一个你熟悉的磁盘臂调度算法进行简单描述。</a> <br>
<a href="#7">7. 进程和线程的区别?</a> <br>
<a href="#8">8. 操作系统的换页方法。</a> <br>
<a href="#9">9. 哲学家进餐问题的无死锁算法。</a> <br>
<a href="#9">9. 操作系统的内存管理。</a> <br>

### <a name="1">1. 进程间的通信方式(IPC)?进程调度方法?</a>

1.共享内存 <br>
2.消息队列 <br>
3.信号 <br>
4.信号量 <br>
5.套接字 <br>
6.普通管道 <br>
7.有名管道 <br> 在无亲缘关系的进程之间通信

- 共享内存 <br>
&ensp;&ensp;&ensp;&ensp;
    可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存
空间,不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式
需要依靠某种同步操作,如互斥锁和信号量等。

- 消息队列 <br>
&ensp;&ensp;&ensp;&ensp;
    “消息队列”是在消息的传输过程中保存消息的容器。具有写权限得进程可
以按照一定得规则向消息队列中添加新信息;对消息队列有读权限得进程则可
以从消息队列中读取信息。
- 信号 <br>
&ensp;&ensp;&ensp;&ensp;
    信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生。
- 信号量 <br>
&ensp;&ensp;&ensp;&ensp;
    信号量是一个计数器,可以用来控制多个进程对共享资源的访问。它常作
为一种锁机制,防止某进程正在访问共享资源时,其他进程也访问该资源。因
此,主要作为进程间以及同一进程内不同线程之间的同步手段。
- 套接字 <br>
&ensp;&ensp;&ensp;&ensp;
    这是一种更为一般得进程间通信机制,它可用于网络中不同机器之间的进程
间通信,应用非常广泛。
- 普通管道 <br>
&ensp;&ensp;&ensp;&ensp;
    普通管道是一种半双工的通信方式,数据只能单向流动,而且只能在具有
父子关系的进程间使用。
- 有名管道 <br>
&ensp;&ensp;&ensp;&ensp;
    有名管道也是半双工的通信方式,但是它允许无亲缘关系进程间的通信。

### <a name="2">2. 线程间解决冲突的方式?</a>
- 锁机制:包括互斥锁、读写锁、条件变量
  * 互斥锁提供了以排他方式防止数据结构被并发修改的方法。
  * 读写锁允许多个线程同时读共享数据,而对写操作是互斥的。
  * 条件变量可以以原子的方式阻塞进程,直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

- 信号量机制(Semaphore):包括无名线程信号量和命名线程信号量。
- 自旋锁
- 信号机制(Signal):类似进程间的信号处理。
- atomic

&ensp;&ensp;&ensp;&ensp;
    线程间的通信目的主要是用于线程同步,所以线程没有像进程通信中的用
于数据交换的通信机制。

### <a name="4">4. 操作系统由哪些部分组成?</a>
&ensp;&ensp;&ensp;&ensp;
    进程管理,存储管理,设备管理,文件管理,程序接口,用户界面。
    
### <a name="5">5. 用户态和系统态在什么时候进行切换?平时用的都是 64 位系统,那它和 32 位系统相比,有什么区别和优点?</a>
以下三种情况会导致用户态到内核态的切换: <br>
1.系统调用; <br>
2.异常,比如缺页异常; <br>
3.外围设备的中断,当外围设备完成用户请求的操作后,会向 CPU 发出相应的
中断信号。 <br>

1)寻址能力不同;2)运算速度不同。

### <a name="6">6. 选择一个你熟悉的磁盘臂调度算法进行简单描述。</a>

1.FCFS：先来先服务算法 <br>
2.SSTF：最短寻道时间算法 <br>
3.SCAN：扫描算法（也叫电梯调度算法）<br>
4.CSCAN：循环扫描算法 <br>

- FCFS：算法思想非常简单，就是不论初始磁头在什么位置，都是按照服务队列的先后顺序依次处理进程，可以类比队列的先进先出。优点是进程处理起来非常简单，但缺点显而易见，就是平均寻道长度会很长。    
  
- SSTF:最短寻道时间算法，算法本质是贪心，已知磁头的初始位置，则最先被处理就是距离磁头位置最近的进程，处理完成后再处理距离当前磁道最近的进程，直到所有的进程被处理。该算法的优点是平均寻道长度会大大减少，缺点是距离初始磁头较远的服务长期得不到处理，产生“饥饿”现象。具体的思路是：通过循环寻找与初始磁头最近的进程，将进程处理，然后将该进程
标记为-1，将初始磁头移动到该进程所在的磁道。然后依次类推，标记为-1的进程不再参与，知道所有的进程都被标记为-1，磁盘调度完成。

- SCAN:磁头仅沿一个方向进行扫描，在扫描途中完成所有没有完成的请求，直到磁头到达磁盘在这个方向上的最后一个磁道或者这个方向上最后一个请求所在的磁道。利用数组存储进程和磁道编号，依据给定的初始磁头，先找到初始磁头在哪两个进程之间，然后向内扫描。当磁头扫描到磁盘最内层即磁道0且进程还没有全部被处理，磁头开始向外扫描，直到所有的进程都完成。

- CSCAN：在磁盘扫描算法的基础上改变磁头的扫描路径：扫描到最内层之后从最外层向内继续扫描，即扫描方向一致。
该算法的思路与扫描算法基本一致，也使用二维数组进行进程编号和进程所在磁道号的存储，算法的不同之处在于当磁
头扫描到磁盘的最内层时，磁头跳转到磁盘最外层重新向内扫描，这样就可以有效的避免将已经扫描过的磁道重新扫描
一次，降低了平均寻到距离。


### <a name="7">7. 进程和线程的区别?</a>
- 调度:线程作为调度和分配的基本单位,进程作为拥有资源的基本单
位。 
- 并发性:不仅进程之间可以并发执行,同一个进程的多个线程之间也可
并发执行。
- 拥有资源:进程是拥有资源的一个独立单位,线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器、一组寄存器和栈),但是它可以与同属一个进程的其他线程共享进程所拥有的全部资源。进程之间是不能共享地址空间的, 而线程是共享着所在进程的地址空间的。 
- 系统开销:在创建或撤消进程时,由于系统都要为之分配和回收资源,
导致系统的开销明显大于创建或撤消线程时的开销。 
- 在linux中，共享地址空间，文件系统资源，文件描述符和信号处理函数的进程叫做线程

### <a name="8">8. 操作系统的换页方法。</a>
FIFO、LRU、OPT 等。 <br>

这三个置换算法，或者说缓存调度算法，其实来源于操作系统的页置换算法。 <br>
FIFO：即 First In, First Out 。 <br>
LRU: Least recently used，最近最少使用算法。即是将最近最少使用的对象踢出内存。 <br>
OPT: Optimal，最优替换，也就是上帝模式。它是考虑当前内存中的对象，以及将来要放进内存的对象，然后，将在最远的将来才被访问的页面踢出内存。所以，这个算法在转换时，需要把将来即将放进内存的对象考虑进去，才能找到要踢出内存的对象。 <br>

一．FIFO：First In, First Out，先进先出算法
1.1 先进先出算法基本思想：
    淘汰最先进入的页面，选择在内存中驻留最久的页面的予以淘汰。
基本思想就是将先进入队列的页面先淘汰掉，如果该页面后期被命中，那也不将它的步数重置，而是按照它第一次进入页面开始记步数。 <br>

二. LRU: Least recently used，最近最少使用算法。即是将最近最少使用的对象踢出内存。
2.1 LRU置换算法基本思想： <br>
&ensp;&ensp;&ensp;&ensp;
    Lru算法和fifo最大相似点就是淘汰前向步数最大的页面，也就是淘汰页面的判断依据是该
页面的从前到后的步数统计，越大表明越是长时间为用到，所以予以淘汰替换。
单很明显是由明显区别的，那就是lru算法当遇到命中时会将该页面重置步数。 <br>
2.2具体操作思想 <br>

三．Optimal: Optimal，最优替换，也就是上帝模式。它是考虑当前内存中的对象，以及将来要放进
内存的对象，然后，将在最远的将来才被访问的页面踢出内存。所以，这个算法在转换时，需
要把将来即将放进内存的对象考虑进去，才能找到要踢出内存的对象。 <br>
3.1 最佳置换算法基本思想：
    将以后永不使用的淘汰，或者是将在最长（未来）时间内不在访问的页面淘汰。由于不能知道或预测谁是最可能永不使用或者长时间使用的页面，所以不能拿它来作为页面置换实际操作中的算法，但是可以用于评估其他算法。
（未被命中的即为“缺页”，缺页率=未命中数/总数，淘汰率=替换数/总数） <br>



### <a name="9">9. 哲学家进餐问题的无死锁算法。</a>
A.原理:仅当哲学家的左右两支筷子都可用时,才允许他拿起筷子进餐。 <br>

方法 1:利用 AND 型信号量机制实现:根据课程讲述,在一个原语中,将一段
代码同时需要的多个临界资源,要么全部分配给它,要么一个都不分配,因此
不会出现死锁的情形。当某些资源不够时阻塞调用进程;由于等待队列的存在,
使得对资源的请求满足 FIFO 的要求,因此不会出现饥饿的情形。 <br>
伪码:

方法 2:利用信号量的保护机制实现。通过信号量 mutex 对 eat()之前的取左
侧和右侧筷子的操作进行保护,使之成为一个原子操作,这样可以防止死锁的
出现。 

B.原理:规定奇数号的哲学家先拿起他左边的筷子,然后再去拿他右边的筷子;
而偶数号的哲学家则相反。按此规定,将是 1,4 号哲学家竞争 4 号筷子,2,3 号哲
学家竞争 2 号筷子.即五个哲学家都竞争偶数号筷子,获得后,再去竞争奇数号筷
子,最后总会有一个哲学家能获得两支筷子而进餐。而申请不到的哲学家进入阻
塞等待队列,根据 FIFO 原则,则先申请的哲学家会较先可以吃饭,因此不会出
现饿死的哲学家。 <br>


### <a name="10">10. 操作系统的内存管理。</a>
1 分区管理 <br>
2 分页管理 <br>
3 分段管理 <br>
4.段页式管理 <br>

### 孤儿进程是什么？如何解决？
父进程终止了
会被init接管，父进程id为1

### 僵尸进程是什么？如何解决？
子进程结束之后，父进程没有接管其结束状态之前
调用wait，两次fork

### DMA是什么？
是一种不经过CPU而直接从内存存取数据的数据交换模式

### 进程的内存布局
这里注意一个细节，那就是空间分布的下面
是程序段，往上是初始化过的数据段，再往上是未初始化过的数据段
然后是堆，共享内存，栈


### 守护进程
又称精灵进程，是后台服务进程，通常独立于服务终端并且周期性的执行任务
如何创建守护进程？
最关键的步骤是创建一个会话，并且成为会话leader
关闭父进程
设置为根目录
设置文件掩码
关闭文件描述符

### 会话
比进程组更高一级，多个进程组对应一个会话

### 进程有哪些状态？
初始态，就绪态，执行态，等待态，终止态

