- 说一下磁盘空间分配的方法？分别有什么特点？
连续分配 连续分配文件所需的寻道时间最小 但是有文件空间分配的问题
链接分配 链接分配采用链表的方式进行分配，问题有：寻址时间过长，指针占用的空间大，可靠性问题 解决方法：将多个块组成簇，按簇而非块进行分配，这样减少了前面的两个问题，但是会产生内碎块；解决可靠性问题的方案有：双向链表，每块加入文件名称和相对块号。 
索引分配 索引分配解决了连续分配的外部碎片问题 
以unix的inode为例，文件索引块前面12个是直接块，不需要单独的索引块，因此小于48kb的数据可以直接访问，对于后面的文件采用一级间接，二级间接和三级间接

- 如何选择磁盘空间分配的方法？
对于小文件采用连续分配，对于大文件采用索引分配
可以采用增加指令的方法节省磁头移动

- 了解文件分配表吗？
文件分配表FAT，每个磁盘卷开头部分用于存储该表，在该表中，每一个磁盘块都有一个条目，并且可以按照块号来索引。
FAT可能导致大量的磁头寻道时间，但是优点是改善了随机访问时间。
没有FAT链接分配就不能支持高效的直接访问。

- 文件空间分配有什么问题呢？解决算法是什么？
有三种解决算法：
最先分配，最优分配，最坏分配

- 什么是文件？
文件是逻辑外存的最小分配单元。数据只有通过文件才能写到外存。

- 操作系统如何实现多个进程打开同一个文件的？
通常操作系统采用两级的内部表：每个进程表和整个系统表。
每个进程表跟踪它打开的所有文件，该表所存的是进程对文件的使用信息。
单个进程表每个条目相应的指向系统的打开文件表，系统表包含了进程无关的信息，进程不打开文件这些信息是不在系统表中的。系统表还关联一个打开计数，用于表示多少个进程打开了这个文件。每次close递减打开技术，当为0时，系统表删除文件条目。

- 协程和线程区别？
我的理解是，线程出现有几种原因，第一个是开销比进程小，第二个是并发和异步实现更加容易，第三个是多核并行的效率提高
而对于前两个，协程比线程更加有用
协程只需要2kb的初始栈，线程需要2mb

- 上下文切换？
进程上下文切换
进程上下文切换发生在内核态
切换页表，切换内核堆栈，切换硬件上下文，切换pcb 刷新tlb虚拟页高速缓存 保存内核状态
线程上下文切换
线程上下文切换根据实现不同发生在内核态或者用户态
切换寄存器，私有数据
中断上下文切换
切换内核态开销
从上下文切换的耗时上来看，Linux线程（轻量级进程）其实和进程差别不太大。

- 死锁的条件？如何避免?
互斥使用
不能剥夺
请求并等待
循环等待

- 内核线程和用户线程的关系？
用户永远比内核线程更多，内核线程是内核的分身，也是用户线程的容器，当一个内核线程获得CPU使用权的时候，加载并且执行一个用户线程
m:n就是内核线程和用户线程的比，表示了线程实现方式

- 逻辑地址，物理地址如何转换？
进程的TLB页表项存储了虚拟地址和偏移，虚拟地址在页表中寻址到物理地址页后和偏移在MMU中相加得到物理地址

- 虚拟内存是什么？
是操作系统对于存储空间提供的虚拟化机制。

- 说一下消息队列内核如何实现的
消息队列可以是一种消息链表。有足够的权限的线程可以往队列中放置消息，有足够读权限的线程可以从队列中取走消息。

- 说一下信号量内核如何实现的
如果有一个任务想要获得已经被占用的信号量时，信号量会将其放入一个等待队列（它不是站在外面痴痴地等待而是将自己的名字写在任务队列中）然后让其睡眠。
当持有信号量的进程将信号释放后，处于等待队列中的一个任务将被唤醒（因为队列中可能不止一个任务），并让其获得信号量。
信号量的数据结构，可以看出其由自旋锁、计数和一个链表头组成。
这里自旋锁 lock用于保护数据的访问，而链表 wait_list则用于记录有那些线程在等待该信号量。

- 信号量pv的原理是什么？    
P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行
V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.

- 为什么不建议使用信号量？
因为信号量更容易出错，可以使用mutex+条件变量，更不容易出错

- 说一下消息队列和管道的区别？
消息队列和管道的对比
1.匿名管道是跟随进程的，消息队列是跟随内核的，也就是说进程结束之后，匿名管道就死了，但是消息队列还会存在（除非显示调用函数销毁）
2.有名管道是文件，存放在磁盘上，访问速度慢，消息队列是数据结构，存放在内存，访问速度快
3.管道是数据流式存取，消息队列是数据块式存取

- 说一下消息队列和共享内存的区别？
消息传递对于交换较少数量的数据很有用，因为无需避免冲突。对于分布式系统，消息传递也比共享内存更易实现。共享内存可以快于消息传递，这是因为消息传递的实现经常采用系统调用，因此需要消耗更多时间以便内核介入。与此相反，共享内存系统仅在建立共享内存区域时需要系统调用；一旦建立共享内存，所有访问都可作为常规内存访问，无需借助内核。
对具有多个处理核系统的最新研究表明，在这类系统上，消息传递的性能要优于共享内存。共享内存会有高速缓存一致性问题，这是由共享数据在多个高速缓存之间迁移而引起的。随着系统的处理核的数量的日益增加，可能导致消息传递作为 IPC 的首选机制。

- 共享内存在哪？有什么用？如何实现？
所有进程共享的一段物理空间

- linux分为几种栈？
分为线程栈，进程栈，进程内核栈，中断内核栈

- sendfile和mmap的区别？
sendfile实现了内核缓冲区的0拷贝，mmap会创建内核和用户共享的缓冲区，减少了read和write一半的拷贝

- 段页式访问几次内存?
三次
拿到逻辑地址
根据逻辑地址找页表项，之后mmu加偏移
根据地址访问物理地址

- exec函数的作用就是：装载一个新的程序（可执行映像）覆盖当前进程内存空间中的映像，从而执行不同的任务。

内核只为新生成的子进程创建虚拟空间结构，它们来复制于父进程的虚拟究竟结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间

对于vfork，连虚拟空间也不创建了



