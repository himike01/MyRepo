- 继承的缺点在哪里？
继承容易造成层次不清，代码混乱，造成代码深度过深，是一种反模式（组合优于继承）所以go抛弃了继承
- 如何实现多态？
继承加方法重写
接口类语法
duck-typing语法：只要两个类有相同的方法，就可以实现多态，不要求两个类有任何关系
- 什么叫基于接口而非实现编程？
- 如何减少继承？
通过组合接口和委托替代继承
- 什么是贫血模型（ADM）？什么是充血模型？为什么充血模型只改造service层？
只包含数据，不包含业务逻辑的类，就叫做贫血模型
贫血模型：Service包含Service和BO类，BO只包含数据
充血模型：Service包含Service和Domain类，Domain包含业务逻辑和数据，DDD就是一种充血模型。Domain要保持独立性，由Service负责和其它层交互
因为Controller层的VO只是DTO（数据传输对象），没有复杂的业务逻辑。

- 为什么不推荐贫血模型？
1. SQL可复用性差
2. 开发流程有区别，贫血模型是SQL-Driven的，充血模型则是DDD领域驱动的，更好的业务流程设计和复杂系统设计

- 开发者需要遵守的设计原则有哪些？
单一职责原则、开闭原则、里氏替换原则、接口隔离原则（多个或者单个API接口/OOP接口）、控制反转原则、依赖倒置原则、KISS原则（尽量简单）、YAGNI（不要过度设计）、DRY（不要重复代码，提高复用性）、迪米特法则（高内聚，低耦合，尽量只依赖必要的接口），基于接口而非实现编程，良好的可测试性（不好的包括：未决行为、滥用全局变量、静态方法、复杂继承、高耦合代码）


- 设计模式分为哪几类？
创建型，结构型，行为型

- 如何实现一个单例模式？
构造函数private，线程安全，延迟加载
饿汉式（不支持delay load）
懒汉式（锁粒度高）
静态内部类（调用时实例化实现delay load）
双重检测
```java
public static IdGenerator getInstance(){
    if(instance == null){
        synchronized(IdGenerator.class){
            if(instance==null) instance = new IdGenerator();//新版jdk中，此步是原子的
        }
    }
    return instance;
}
```

- 为什么不推荐单例模式？
对oop支持不好，会隐藏类之间的依赖关系，对代码的扩展性不友好，对可测试性不友好，无法mock，不支持有参数的构造函数
如果没有对后续扩展的需求，不依赖外部系统，那么单例就没有问题

- 为什么要有工厂模式？
为了让类的职责更加单一，代码更加清晰。

- 为什么要有建造者模式？
当类实例化时所用的参数过多，参数之间有逻辑/约束关系需要校验，创建不可变对象（不设置set）时，需要建造者模式。

- 工厂模式和建造者模式有什么区别？
工厂模式用来创建不同但是是相关类型的对象，由给定参数决定创建哪一种类型的对象
建造者模式用来创建比较复杂的一种对象。

- 为什么要有原型模式？
对象创建成本比较大的时候，可以使用对原型进行拷贝的方式，完成对象的实例化
Prototype 的意义在于，你拿到一个 Base* ，它指向某个 Derived 对象，你想克隆出 Derived 对象，但代码中不写出 Derived 的具体类型，因为有很多派生类，这种情况下你用构造函数是搞不定的，type-switch 是 bad smells 。

- 代理模式用在什么情景下？
业务系统的非功能性需求开发
RPC也算是代理模式
代理模式和原类型实现同样的接口以替代功能

- 如果代理类没有接口怎么办？
动态代理,使用java提供的反射完成

- 桥接模式有什么作用？
桥接模式讲抽象和实现解耦，让它们可以独立变化
jdbc的实现就是桥接模式，第一步要求JVM查找并加载指定的Driver类，第二步执行该类的静态代码，将Driver注册到DriverManager中

- 适配器模式如何实现？
类适配和对象适配，类适配基于

- 代理、桥接、装饰器、适配器四种设计模式有什么区别？
代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，用于控制访问
桥接模式将接口部分和实现部分分离
装饰器模式在不改变原始类接口的情况下，对原始类功能进行增强
适配器模式为原始类提供接口的包装以适配跟原始类不同的接口

- 门面模式是什么？
包装多个接口在一起

- 组合模式是什么？
组合模式将一组对象组织成树形结构，以表示一种部分-整体的层次结构，组合让客户端可以统一单个对象和组合对象的处理逻辑。
（比如设计人员架构图）

- 享元模式是什么？
将部分属性抽象出来作为单例，以供复用。
只需要在工厂类中通过一个Map来缓存一个已经创建过的缓存对象即可

- 
