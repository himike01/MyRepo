-  private, public, protected 访问标号的访问范围
private：只能由1.该类中的函数、2.其友元函数访问。
不能被任何其他访问，该类的对象也不能访问。
protected：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问。
但不能被该类的对象访问。
public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。

- 类被继承后方法属性变化
private 属性不能够被继承。
使用private继承， 父类的protected和public属性在子类中变为private；
使用protected继承，父类的protected和public属性在子类中变为protected；
使用public继承， 父类的protected和public属性不发生改变;

- 说一下C++初始化顺序？
变量的初始化顺序就应该是：
1 基类的静态变量或全局变量
2 派生类的静态变量或全局变量
3 基类的成员变量
4 派生类的成员变量
这里需要注意几个重要的点：
1、成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关
2、类中const成员常量必须在构造函数初始化列表中初始化。
3、注意：类中static成员变量，必须在类外初始化。

- 什么时候会产生默认构造函数？
implicate no trivial default constructor

- C++默认产生哪些函数？
默认构造函数，析构函数，拷贝构造函数，拷贝赋值运算符

- C++中类成员的默认访问级别是什么？
private

- 比较一下指针和引用使用的场景？
引用可以防止传递nullptr

- std::move的使用场景是什么？
```c
我们有一个左值，希望像右值一样处理它
Person p{"Jack"}; // 创建一个临时变量，如果一个move；多半情况下编译器会直接创建在Person里
std::string name{"John"};
Person p1{name}; // 这种情况跟用const引用一样，都是一次copy
Person p2{std::move(name)}; // 因为被转化成了右值，name会被直接移动到p2里，省掉一次copy
```

- 请解释一下COW和SSO
1.COW
思想是只有当修改string的时候再为这个修改操作重新生成一个拷贝，如果只是复制，那么就是共享这个数据。COW的实现机制是用一个引用计数，初始值是1，每次赋值的时候都会加1。当修改的时候，如果count > 1， 则会重新申请空间并复制，并且count--（因为正在修改的这个之前肯定是引用了这个数据），然后如果count = 0， 则释放原来内存。
需要注意的是，string会把[]跟at()操作认定为修改操作，因为很难定义到底是不是修改，所以一律当成了修改。比如以下的代码，string a = "hi", string b = a; b[0] = 'i';
则a= "hi", b="ii".
2.SSO small string optimization
因为COW的弊端（除了上面提到的，还有其他的，比如多线程问题），新版本的编译器大多放弃了COW，而使用了SSO。SSO思想是立刻复制，同时有一个优化就是当字符串较短时，直接将其数据放到栈中，而不是在堆中动态申请内存，避免了申请空间的开销。
回到开头的例子，就不难理解为什么VS会输出false, false, false了，因为每次都是深拷贝。

- C++函数如何返回多个值？
使用tuple或者pair<bool,Out>
或者optional<Out>

- 如何限制构造函数的隐式拷贝？
使用explicit

- 说一下回调函数和仿函数
仿函数的优点：
1、拥有状态
仿函数的能力超越了operator(),仿函数可以拥有成员函数和成员变量，这就意味着仿函数可以同时拥有状态不同的两个实体。一般函数则达不到这样的能力。
2、拥有自己的型别
我们可以将仿函数的型别当做template参数来传递，从而指定某种行为模式。容器型别也会因为仿函数的不同而不同。
3、仿函数速度更快
就template概念而言，由于很多细节在编译期就已经确定，传入一个仿函数，就可能活动更好的性能。

- 如何使用继承运算符？
使用public，用内含替代其它作用符

- 析构函数何时应该声明为virtual？
当有其它虚函数的时候


- __thread关键字有什么用？
用于修饰pod类型，只能用于初始化编译器常量。每个线程独有一份实体，不相干扰，

- 什么时候使用insert？什么时候使用operator[]？
对于关联容器，在插入时使用insert将会比使用operator[]效率更高；在更新时则相反。

- 比较一下vector和set
vector在结尾插入效率很高，set适合于去重和查找。

- 只有符合设置，查找，重组的时候才考虑用排序的vector代替关联容器

- 说一下static关键字
1. 修饰普通变量，变为全局静态存储区，生命周期得到延长
2. 修饰普通方法，只能在本文件之内访问
3. 修饰成员函数，只有一个实例，不可以访问非静态成员
4. 修饰成员变量，只有一个实例，只能在类外初始化
5. 修饰全局变量  限定作用域 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效

- this指针是什么？
this指针是一个右值，是一个const类型常量，会隐式传递给成员函数

- 虚函数可以内联吗？
虚函数可以在不表现多态性的时候内联

- ※虚函数的内存布局？
单继承的时候，子类的虚函数放在父类的虚函数后面，虚表指针只有一个
虚表中记录偏移和RTTI运行时类型信息，多态函数的偏移
多继承的时候，有多个虚表指针，多份RTTI，虚继承自己也有一份RTTI

- new做了什么？
调用全局operator new；进行一次static_cast；执行构造函数
operator new 调用malloc

- delete做了什么？
析构然后free

- 一直new/malloc不去free会发生什么？
因为向零地址写入而退出

- 说一下Array new发生了什么？
（cookie pad Debugger header）
首先分配空间，在上下边界放入cookie记录了数组大小，Pad负责字节对齐，上边界以下是Debugger Header
如果析构函数是no-trivial的，此时会在Debugger Header下面放入数组大小，以便于destructor/free的调用，此时如果使用delete而非delete[]就会因为布局问题崩溃

- malloc的底层原理？
当开辟空间小于12k时，使用brk调整指针，分配虚拟页（只有程序访问引发缺页中断才会分配物理页）
这样带来的问题就是会产生内碎片
所以对于大于12k的空间，使用mmap在堆和栈中间分配一块内存 
malloc会分配一块mete-data,存储大小和debugger header和对齐


- 各种数据类型的大小？
char 1
short 2 
int 4
long 4
longlong 8
double 8

- 程序运行时的内存结构？
从上到下是（从高地址到低地址）
内核内存
用户栈（向下增长）
共享库的内存映射区域（向上增长）[共享内存]
运行时堆（向上增长，用brk标记位置）
读写段
只读代码段

- 如何建立只在栈上/堆上分配的对象？
将new/delete重载为私有
将析构设置为私有


- 能否在构造/析构函数中调用虚函数？
不能，因为会有类型信息的下降，会下降到derived class

- operator= 应该返回什么？
reference to * this

- public和private分别塑造出什么样的关系？
public是is a的关系，
private是根据某物实现出的关系

- 前置/后置递增/递减有何区别？
前置返回引用，后置返回const，实现上先实现前置

-  什么时候拷贝构造函数不被生成？
不展现逐位次拷贝的时候

- 什么叫友元函数？
定义在类的外部，可以访问任何成员

- if/else过多怎么办
if/else过多 会违反单一职责和开闭原则
表驱动模式，事件驱动，提前return，optional

- 哈希冲突如何解决？

1. 开链表法 ， 将重复的键放入链表
2. 公共溢出区，将重复的键放入这个溢出区
3. 开放定址法，包括线性探测，平方探测，再散列
4. 设计加载因子，在数据增长的时候，进行扩容，减少哈希冲突

- static_cast
非多态转换
不执行运行时类型检查
通常用于数值类型转换
dynamic_cast
多态类型，父子指针转换
const_cast 
删除const特性
reinterpret_cast
位重新解释，指针转换

- 了解STL的空间配置器吗？
空间配置器分为两种，一级空间配置器和二级空间配置器，如果内存大于128字节，那么调用一级内存分配器去申请内存，否则调用二级空间配置器去内存池中分配内存。

- weak_ptr的原理？
可以用不增加引用计数的shared_ptr实现，然后看对象的引用计数为0的时候销毁

- 说一下匿名函数的捕获方式？
如果捕获列表为[&]，则表示所有的外部变量都按引用传递给lambda使用
如果捕获列表为[=]，则表示所有的外部变量都按值传递给lambda使用
匿名函数构建的时候对于按值传递的捕获列表，会立即将当前可以取到的值拷贝一份作为常数，然后将该常数作为参数传递，即：

- 说一下大端和小端，C++怎么判断？
大端就是栈从低往高增长，可以用union来判断，比如放一个int和char，对于0x12345678
大端char是12小端是78
这个地方注意，大端小端只是对于一个字节而言，对整体的数据内存布局没有影响。
所以栈都是往低地址增长的 


- lock_guard和lock_guard的区别？
unique_lock是一个通用的互斥量锁定包装器，它允许延迟锁定，限时深度锁定，递归锁定，锁定所有权的转移以及与条件变量一起使用。
简单地讲，unique_lock 是 lock_guard 的升级加强版，它具有 lock_guard 的所有功能，同时又具有其他很多方法，使用起来更强灵活方便，能够应对更复杂的锁定需要。
特点如下：
创建时可以不锁定（通过指定第二个参数为std::defer_lock），而在需要时再锁定
可以随时加锁解锁
作用域规则同 lock_grard，析构时自动释放锁
不可复制，可移动
条件变量需要该类型的锁作为参数（此时必须使用unique_lock）


- scoped_lock?
它可以同时给多个可锁的对象（lockable object）加锁（使用和std::lock相同的算法），并且在析构函数中释放锁

- 如何对迭代器erase/remove？
对于序列化容器，每次erase会返回下一个有效的iter，需要接收这个值
对于关联容器，需要用右增来遍历，这样删除的是当前值的副本。

- 为什么Google规范推荐不要使用异常处理？
在现有函数中添加 throw 语句时，您必须检查所有调用点。要么让所有调用点统统具备最低限度的异常安全保证，要么眼睁睁地看异常一路欢快地往上跑，最终中断掉整个程序。举例，f() 调用 g(), g() 又调用 h(), 且 h 抛出的异常被 f 捕获。当心 g, 否则会没妥善清理好。
还有更常见的，异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回。您或许会加一大堆何时何处处理异常的规定来降低风险，然而开发者的记忆负担更重了。
异常安全需要RAII和不同的编码实践. 要轻松编写出正确的异常安全代码需要大量的支持机制. 更进一步地说, 为了避免读者理解整个调用表, 异常安全必须隔绝从持续状态写到 “提交” 状态的逻辑. 这一点有利有弊 (因为你也许不得不为了隔离提交而混淆代码). 如果允许使用异常, 我们就不得不时刻关注这样的弊端, 即使有时它们并不值得.
启用异常会增加二进制文件数据，延长编译时间（或许影响小），还可能加大地址空间的压力。
滥用异常会变相鼓励开发者去捕捉不合时宜，或本来就已经没法恢复的「伪异常」。比如，用户的输入不符合格式要求时，也用不着抛异常。如此之类的伪异常列都列不完。

- 虚表存储在哪里?
内存布局的程序数据段

- STL六大组件？
容器，算法，迭代器，仿函数，配接器和配置器

- reserve(n)和resize的区别？
reserve(n)
预分配n个元素的存储空间。
resize
调整容器空间大小

- 指针和引用的区别？
指针和引用主要有以下区别：
引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。
引用初始化后不能被改变，指针可以改变所指的对象。
不存在指向空值的引用，但是存在指向空值的指针。
注意：引用作为函数参数时，会引发一定的问题，因为让引用作参数，目的就是想改变这个引用所指向地址的内容，而函数调用时传入的是实参，看不出函数的参数是正常变量，还是引用，因此可能引发错误。所以使用时一定要小心谨慎。
从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。
而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。


- 静态变量和全局变量的区别？
把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。

 
- 说一下extern关键字
在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。

- 编译链接过程
编译器进行编译过程
预处理，编译，优化
汇编器进行汇编
链接器进行链接


- Unicode与utf-8的区别
unicode是字符集，utf-8是编码规则


- vector为什么是1.5/2?
采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。
1.5比2更优，并且利用了缓存友好
https://www.zhihu.com/question/36538542


- C++线程池大小
N+1 2*N
最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目


- 说一下C++多态
C++多态分为静态多态和动态多态
静态多态指的是在编译期通过函数重载实现了对于父类函数的重写
动态多态指的是在运行时通过虚函数 动态调用了新的函数




- 32位和64位下数据类型的字节大小
除了long和unsigned long不同之外，其余都相同






