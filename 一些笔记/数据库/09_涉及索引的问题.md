# 涉及索引的问题

### 目录

---
<a href="#1">1. 索引的优缺点。</a> <br>
<a href="#2">2. 索引有哪些?</a> <br>
<a href="#3">3. 数据库索引的原理(实现)。</a> <br>
<a href="#4">4. Mysql 的 B+树索引的优点?为什么不用二叉树?B-树和 B+树为什么比红黑树更合适?</a> <br>
<a href="#5">5. 建索引的几大原则。</a> <br>


### <a name="1">1. truncate 与 delete 的区别是什么?</a>
![09_1_1](/data/images/Java应届生面试突击/数据库/09_1_1.png) <br>

### 性别字段为什么不适合加索引?从 B+树原理解释。
&ensp;&ensp;&ensp;&ensp;
    尽量选择区分度高的字段作为索引,区分度的公式是 count(distinct col)/count(*),表示
字段不重复的比例,*比例越大我们扫描的记录数越少*,唯一键的区分度是 1,而一些状态、
性别字段可能在大数据面前区分度就是 0。在性别字段上增加索引,并不能明显加快检索
速度。

### <a name="2">2. 索引有哪些?</a>
主键索引，单列索引，唯一索引，复合索引


#### 扩展:聚集索引和非聚集索引的区别?分别在什么情况下使用?
&ensp;&ensp;&ensp;&ensp;
    聚集索引和非聚集索引的根本区别是表中记录的物理顺序和索引的排列顺
序是否一致。 <br>
&ensp;&ensp;&ensp;&ensp;
    聚集索引的表中记录的物理顺序与索引的排列顺序一致。 <br>
&ensp;&ensp;&ensp;&ensp;
    优点是查询速度快,因为一旦具有第一个索引值的记录被找到,具有连续索
引值的记录也一定物理的紧跟其后。 <br>
&ensp;&ensp;&ensp;&ensp;
    缺点是对表进行修改速度较慢,这是为了保持表中的记录的物理顺序与索引
的顺序一致,而把记录插入到数据页的相应位置,必须在数据页中进行数据重
排,降低了执行速度。 在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的
分裂调整,十分低效。 <br>
&ensp;&ensp;&ensp;&ensp;
    建议使用聚集索引的场合为: <br>
&ensp;&ensp;&ensp;&ensp;
    A.某列包含了小数目的不同值。 <br>
&ensp;&ensp;&ensp;&ensp;
    B.排序和范围查找。 <br>
&ensp;&ensp;&ensp;&ensp;
    非聚集索引的记录的物理顺序和索引的顺序不一致。 <br>
#### 其他方面的区别:
&ensp;&ensp;&ensp;&ensp;
    1. 聚集索引和非聚集索引都采用了 B+树的结构,但非聚集索引的叶子层并
不与实际的数据页相重叠,而采用叶子层包含一个指向表中的记录在数据页中
的指针的方式。聚集索引的叶节点就是数据节点,而非聚集索引的叶节点仍然
是索引节点。 <br>
&ensp;&ensp;&ensp;&ensp;
    2. 非聚集索引添加记录时,不会引起数据顺序的重组。 <br>
&ensp;&ensp;&ensp;&ensp;
&ensp;&ensp;&ensp;&ensp;
        看上去聚簇索引的效率明显要低于非聚簇索引,因为每次使用辅助索引检索都要经过
&ensp;&ensp;&ensp;&ensp;
    两次 B+树查找,这不是多此一举吗?聚簇索引的优势在哪? <br>
&ensp;&ensp;&ensp;&ensp;
&ensp;&ensp;&ensp;&ensp;
        1.由于行数据和叶子节点存储在一起,这样主键和行数据是一起被载入内存的,找到叶子节点就可以立刻将行数据返回了,如果按照主键 Id 来组织数据,获得数据更快。
        2.辅助索引使用主键作为"指针", 而不是使用地址值作为指针的好处是,减少了当出
    现行移动或者数据页分裂时,辅助索引的维护工作,InnoDB 在移动行时无须更新辅助索
    引中的这个"指针"。也就是说行的位置会随着数据库里数据的修改而发生变化,使用聚簇
    索引就可以保证不管这个主键 B+树的节点如何变化,辅助索引树都不受影响。 <br>
&ensp;&ensp;&ensp;&ensp;
    建议使用非聚集索引的场合为: <br>
&ensp;&ensp;&ensp;&ensp;
    a.此列包含了大数目的不同值; <br>
&ensp;&ensp;&ensp;&ensp;
    b.频繁更新的列 <br>
5. 组合索引(联合索引) <br>
基于多个字段而创建的索引就称为组合索引。 <br>
创建索引 <br>
```sql
create index idx1 on table1(col1,col2,col3)
```
查询
```sql
select * from table1 where col1= A and col2= B and col3 = C

```
#### 组合索引查询的各种场景:
组合索引 Index (A, B, C)

- 下面条件可以用上该组合索引查询:
    -  A>5
    - A=5 AND B>6
    - A=5 AND B=6 AND C=7
    - A=5 AND B=6 AND C IN (2, 3)

- 下面条件将不能用上组合索引查询:
    - B>5 ——查询条件不包含组合索引首列字段
    - B=6 AND C=7 ——理由同上

- 下面条件将能用上部分组合索引查询(重要!!!!):
    - A>5 AND B=2 ——当范围查询使用第一列,查询条件仅仅能使用第一列
    - A=5 AND B>6 AND C=2 ——范围查询使用第二列,查询条件仅仅能使用前二列
    - A=5 AND B IN (2, 3) AND C=2

#### 组合索引排序的各种场景:
兹有组合索引 Index(A,B)。

- 下面条件可以用上组合索引排序:
 - ORDER BY A——首列排序
 - A=5 ORDER BY B——第一列过滤后第二列排序
 - ORDER BY A DESC, B DESC——注意,此时两列以相同顺序排序
 - A>5 ORDER BY A——数据检索和排序都在第一列

- 下面条件不能用上组合索引排序:
 - ORDER BY B ——排序在索引的第二列
 - A>5 ORDER BY B ——范围查询在第一列,排序在第二列
 - A IN(1,2) ORDER BY B ——理由同上
 - ORDER BY A ASC, B DESC ——注意,此时两列以不同顺序排序
 
```sql
alter table users add index lname_fname_age(lname,fname,age);

```
&ensp;&ensp;&ensp;&ensp;
    创建了 lname_fname_age 多列索引,相当于创建了(lname)单列索引,
(lname,fname)联合索引以及(lname,fname,age)联合索引。

*举例说明:* <br>
&ensp;&ensp;&ensp;&ensp;
    上面给出一个多列索引(username,password,last_login),当
三 列 在 where 中 出 现 的 顺 序 如 (username,password,last_login) 、
(username,password)、 (username) 才能 用 到 索引 ,如 下面几 个顺 序
(password,last_login) 、 (passwrod) 、 (last_login)--- 这 三 者 不 从
username 开始,(username,last_login)---断层,少了 password,都无
法利用到索引。因为 B+tree 多列索引保存的顺序是按照索引创建的顺序,
检索索引时按照此顺序检索。

### <a name="3">3. 数据库索引的原理(实现)。</a>
&ensp;&ensp;&ensp;&ensp;
    目前大部分数据库系统及文件系统都采用 B-Tree( B 树)或其变种 B+Tree
(B+树)作为索引结构。B+Tree 是数据库系统实现索引的首选数据结构。
&ensp;&ensp;&ensp;&ensp; <br>
    在 MySQL 中,索引属于存储引擎级别的概念,不同存储引擎对索引的实现方式
是不同的,本文主要讨论 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。
MyISAM 索引实现 <br>
&ensp;&ensp;&ensp;&ensp;
    MyISAM 引擎使用 B+Tree 作为索引结构,叶节点的 data 域存放的是数据记录
的地址。下图是 MyISAM 索引的原理图: <br>
![09_3_1](/data/images/Java应届生面试突击/数据库/09_3_1.png) <br>
主键索引

&ensp;&ensp;&ensp;&ensp;
    这里设表一共有三列,假设我们以 Col1 为主键,则图 8 是一个 MyISAM 表的主
索引(Primary key)示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。
在 MyISAM 中,主索引和辅助索引(Secondary key)在结构上没有任何区别,只
是主索引要求 key 是唯一的,而辅助索引的 key 可以重复。如果我们在 Col2 上建立
一个辅助索引,则此索引的结构如下图所示: <br>
![09_3_2](/data/images/Java应届生面试突击/数据库/09_3_2.png) <br>
辅助索引

&ensp;&ensp;&ensp;&ensp;
    同样也是一颗 B+Tree,data 域保存数据记录的地址。因此,MyISAM 中索引
检索的算法为首先按照 B+Tree 搜索算法搜索索引,如果指定的 Key 存在,则取出其
data 域的值,然后以 data 域的值为地址,读取相应数据记录。 <br>
&ensp;&ensp;&ensp;&ensp;
    MyISAM 的索引方式也叫做“非聚集索引”,之所以这么称呼是为了与 InnoDB
的聚集索引区分。 <br>
InnoDB 索引实现 <br>
&ensp;&ensp;&ensp;&ensp;
    虽然 InnoDB 也使用 B+Tree 作为索引结构,但具体实现方式却与 MyISAM 截
然不同。 <br>
&ensp;&ensp;&ensp;&ensp;
    1.第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道,
MyISAM 索引文件和数据文件是分离的,索引文件仅保存数据记录的地址。而在
InnoDB 中,表数据文件本身就是按 B+Tree 组织的一个索引结构,这棵树的叶节点
data 域保存了完整的数据记录。这个索引的 key 是数据表的主键,因此 InnoDB 表数
据文件本身就是主索引。 <br>
![09_3_3](/data/images/Java应届生面试突击/数据库/09_3_3.png) <br>
主索引

&ensp;&ensp;&ensp;&ensp;
    上图是 InnoDB 主索引(同时也是数据文件)的示意图,可以看到叶节点包含了完整
的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集,
1. InnoDB 要求表必须有主键(MyISAM 可以没有),如果没有显式指定,则 MySQL
系统会自动选择一个可以唯一标识数据记录的列作为主键,如果不存在这种列,则
MySQL 自动为 InnoDB 表生成一个隐含字段作为主键,类型为长整形。同时,请尽
量 2.在 InnoDB 上采用自增字段做表的主键。因为 InnoDB 数据文件本身是一棵
B+Tree,非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频
繁的分裂调整,十分低效,而使用自增字段作为主键则是一个很好的选择。如果表使用
自增主键,那么每次插入新的记录,记录就会顺序添加到当前索引节点的后续位置,当
一页写满,就会自动开辟一个新的页。如下图所示: <br>
![09_3_4](/data/images/Java应届生面试突击/数据库/09_3_4.png) <br>

这样就会形成一个紧凑的索引结构,近似顺序填满。由于每次插入时也不需要移动已有
数据,因此效率很高,也不会增加很多开销在维护索引上。
2. 第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储相应记录
主键的值而不是地址。换句话说,InnoDB 的所有辅助索引都引用主键作为 data 域。
例如,图 11 为定义在 Col3 上的一个辅助索引: <br>
![09_3_5](/data/images/Java应届生面试突击/数据库/09_3_5.png) <br>
辅助索引

聚集索引这种实现方式使得按主键的搜索十分高效, 
但是辅助索引搜索需要检索两遍索 <br>
引:首先检索辅助索引获得主键,然后用主键到主索引中检索获得记录。 <br>
引申:为什么不建议使用过长的字段作为主键? <br>
&ensp;&ensp;&ensp;&ensp;
    因为所有辅助索引都引用主索引,过长的主索引会令辅助索引变得过大。
#### 扩展阅读 1:
InnoDB 使用的是聚簇索引,将主键组织到一棵 B+树中,而行数据就储存在叶子节
点上,若使用"where id = 14"这样的条件查找主键,则按照 B+树的检索算法即可查找到
对应的叶节点,之后获得行数据。若对 Name 列进行条件搜索,则需要两个步骤:第一步
在辅助索引 B+树中检索 Name,到达其叶子节点获取对应的主键。第二步使用主键在主
索引 B+树种再执行一次 B+树检索操作,最终到达叶子节点即可获取整行数据。
MyISM 使用的是非聚簇索引,非聚簇索引的两棵 B+树看上去没什么不同,节点
的结构完全一致只是存储的内容不同而已,主键索引 B+树的节点存储了主键,辅助键索引
B+树存储了辅助键。表数据存储在独立的地方,这两颗 B+树的叶子节点都使用一个地址
指向真正的表数据,对于表数据来说,这两个键没有任何差别。由于索引树是独立的,通
过辅助键检索无需访问主键的索引树。 <br>
为了更形象说明这两种索引的区别,我们假想一个表如下图存储了 4 行数据。其中
Id 作为主索引,Name 作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。 <br>
![09_3_6](/data/images/Java应届生面试突击/数据库/09_3_6.png) <br>

#### 扩展阅读 2:
![09_3_7](/data/images/Java应届生面试突击/数据库/09_3_7.png) <br>

b 树的查找过程: <br>
&ensp;&ensp;&ensp;&ensp;
    如图所示,如果要查找数据项 29,那么首先会把磁盘块 1 由磁盘加载到内存,
此时发生一次 IO,在内存中用二分查找确定 29 在 17 和 35 之间,锁定磁盘块 1 的 P2
指针,内存时间因为非常短(相比磁盘的 IO)可以忽略不计,通过磁盘块 1 的 P2 指
针的磁盘地址把磁盘块 3 由磁盘加载到内存,发生第二次 IO,29 在 26 和 30 之间,
锁定磁盘块 3 的 P2 指针,通过指针加载磁盘块 8 到内存,发生第三次 IO,同时内存
中做二分查找找到 29,结束查询,总计三次 IO。真实的情况是,3 层的 b+树可以表
示上百万的数据,如果上百万的数据查找只需要三次 IO,性能提高将是巨大的,如果
没有索引,每个数据项都要发生一次 IO,那么总共需要百万次的 IO,显然成本非常非
常高。 <br>
&ensp;&ensp;&ensp;&ensp;
    注意:当 b+树的数据项是复合的数据结构(建立的是复合索引),比如
(name,age,sex)的时候,b+树是按照从左到右的顺序来建立搜索树的,比如当(张
三,20,F)这样的数据来检索的时候,b+树会优先比较 name 来确定下一步的搜索方向,
如果 name 相同再依次比较 age 和 sex,最后得到检索的数据;但当(20,F)这样的没
有 name 的数据来的时候,b+树就不知道下一步该查哪个节点,因为建立搜索树的时
候 name 就是第一个比较因子,必须要先根据 name 来搜索才能知道下一步去哪里查
询。比如当(张三,F)这样的数据来检索时,b+树可以用 name 来指定搜索方向,但下
一个字段 age 的缺失,所以只能把名字等于张三的数据都找到,然后再匹配性别是 F
的数据了, 这个是非常重要的性质,即索引的最左匹配特性。注意:B+tree 多列索
引保存的顺序是按照索引创建的顺序,检索索引时按照此顺序检索。 <br>
&ensp;&ensp;&ensp;&ensp;
    最左前缀原则中 where 字句有 or 出现还是会遍历全表。

### <a name="4">4. Mysql 的 B+树索引的优点?为什么不用二叉树?B-树和 B+树为什么比红黑树更合适?</a>
&ensp;&ensp;&ensp;&ensp;
    数据库文件很大,需要存储到磁盘上,索引的结构组织要尽量减少查找过程中磁盘
I/O 的存取次数。 <br>
1.高度原因 <br>
&ensp;&ensp;&ensp;&ensp;
    B+树中的每个结点可以包含大量的关键字,这样树的深度降低了,所以任何关键
字的查找必须走一条从根结点到叶子结点的路,所有关键字查询的路径长度相同,导致
每一个数据的查询效率相当, 这就意味着查找一个元素只要很少结点从外存磁盘中读入
内存,很快访问到要查找的数据,减少了磁盘 I/O 的存取次数。 <br>
2.磁盘预读原理和局部性原理 <br>
&ensp;&ensp;&ensp;&ensp;
    将一个节点的大小设为等于一个页,这样每个节点只需要一次 I/O 就可以完全载
入。

### <a name="5">5. 建索引的几大原则。</a>
1. 最左前缀匹配原则,mysql 会一直向右匹配直到遇到范围查询(>、<、between、
like)就停止匹配,范围查询会导致组合索引半生效。 <br>
&ensp;&ensp;&ensp;&ensp;
    比如 a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引,c 可
以用到索引,d 是用不到索引的,如果建立(a,b,d,c)的索引则都可以用到,a,b,d 的顺
序可以任意调整。where 范围查询要放在最后 (这不绝对,但可以利用一部分索引)。
特别注意:and 之间的部分可以乱序,比如 a = 1 and b = 2 and c = 3 建立(a,b,c)
索引可以任意顺序,mysql 的查询优化器会帮你优化成索引可以识别的形式。 <br>
&ensp;&ensp;&ensp;&ensp;
    where 字句有 or 出现还是会遍历全表。 <br>
2. 尽量选择区分度高的字段作为索引,某字段的区分度的公式是 count(distinct
col)/count(*),表示字段不重复的比例,比例越大,我们扫描的记录数越少, 查找匹配
的时候可以过滤更多的行, 唯一索引的区分度是 1,而一些状态、性别字段可能在大数
据面前区分度就是 0。
4. 不在索引列做运算或者使用函数。
5. 尽量扩展索引,不要新建索引。比如表中已经有 a 的索引,现在要加(a,b)的索引,那
么只需要修改原来的索引即可。
6. Where 子句中经常使用的字段应该创建索引,
分组字段或者排序字段应该创建索引,
两个表的连接字段应该创建索引。
7. like 模糊查询中,右模糊查询(321%)会使用索引,而%321 和%321%会放弃索引
而使用全局扫描。



---
### 搬运工信息
Author:Jason Lou <br>
Email:vip.iotworld@gmail.com <br>
Blog:https://blog.csdn.net/qq_21508727 <br>
Github:https://github.com/JGPY/JavaGuideBooster <br>
---