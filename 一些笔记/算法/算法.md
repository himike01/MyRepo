- sort是快排吗？
不是，sort先分段，然后如果数据量小的话，采用插入排序；如果递归深度深的话，采用堆排序。 在两种情况之间时，快排

- 堆是什么？如何构造大顶堆？如何进行堆排序？
堆是一个完全二叉树
大顶堆从最后的非叶子节点开始，比较子节点和父节点，如果节点变动，就调整子节点
堆排序每次把大顶堆的最后一个节点和根节点互换，然后对根节点调整子节点

- 红黑树的特征
节点是红色/黑色
根节点是黑色
所有叶子节点是黑色
红色节点的子节点是黑色
从任意节点出发，黑色节点数目相同
红黑树高度不超过2logn+1
高度差在2层之内
左旋：两个红色节点相邻的时候进行，以某节点作为旋转节点，右子节点变成旋转节点的父节点，右子节点的左子节点变成旋转节点的右子节点，左子节点保持不变


- B树，B+树？
B树是一个平衡多路查找树，利用了磁盘预读原理，减少了查询次数和复杂度
B+树相比B树层级更少，查询速度更稳定，全节点遍历更快且天然具有排序功能

- 说一下常见排序算法
冒泡
选择
插入
都是n^2
快排
堆排
归并
希尔    先进行一个增量排序，然后进行插入排序
都是nlogn
计数排序
桶排序
基数排序    按照数位进行排序
都是n+m 

- 快慢指针可以为3步吗？4步呢？
一句话，相遇时，跑的快的多跑了若干圈，证明步数差有可能为环长度的整数倍就行了。
如果是一步两步快慢指针，经历时间T后相遇，此时步数差为T，假设环周长为某个整数L。
证明存在T使得，T /L 为整数，T值为L倍数就行了，比如L,2L,3L,……，这显然成立。
那么是一步三步，是一步四步呢？
如果是一步三步快慢指针，证明存在T使得，2T /L 为整数，加个系数2而已，显然存在T使得，2T /L 为整数。
如果是一步四步快慢指针，证明存在T使得，3T /L 为整数，加个系数3而已，显然存在T使得，3T /L 为整数。

其实是证明差的n倍是圈数的整数倍，所以可以


- 快排如何优化？
三数取中基准
尾递归优化
三向切分
聚集元素，在一次分割结束后，将与本次基准相等的元素聚集在一起，再分割时，不再对聚集过的元素进行分割

- 如何提高快排的稳定性？


- 快排最差的情况
1）数组已经是正序（same order）排过序的。
2）数组已经是倒序排过序的。
3）所有的元素都相同（1、2的特殊情况）


- 哈希算法有哪些？
加法哈希
减法
MD5
SHA1
redis和nginx中还有一致性哈希
能实现负载均衡，增加复用性

- 如何使用2G内存空间找出10G数据的中位数？
1. 取最高八位，根据高八位的大小。放入255个桶中，每个桶写入一个磁盘文件
2. 可以确定中位数在哪个桶里
3. 循环上述过程，最后使用一次快排

- 哪些排序是稳定的？
堆排序 、 快速排序 、 希尔排序 、 直接选择排序 是不稳定的排序算法，而 基数排序 、 冒泡排序 、 直接插入排序 、 折半插入排序 、 归并排序 是稳定的排序算法


- topk问题
1. 找到最大的1万个
map去重
分治后最小堆
再次最小堆

单机多核：分成多个partition


- map用在什么场景？
map始终保证遍历的时候是按key的大小顺序的，这是一个主要的功能上的差异
map可以做范围查找，而unordered_map不可以。
map的iterator除非指向元素被删除，否则永远不会失效。unordered_map的iterator在对unordered_map修改时有时会失效。
因为3，所以对map的遍历可以和修改map在一定程度上并行（一定程度上的不一致通常可以接受），而对unordered_map的遍历必须防止修改
map的iterator可以双向遍历，这样可以很容易查找到当前map中刚好大于这个key的值，或者刚好小于这个key的值


