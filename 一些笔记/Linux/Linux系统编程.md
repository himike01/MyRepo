- 你说到了文件描述符非阻塞，那能不能说一下为什么设置为非阻塞，什么是非阻塞？
阻塞是设备文件和网络文件的属性，常规文件没有阻塞概念，如果设置为非阻塞，那么发现文件内容为空的时候，也不会阻塞等待，而是直接返回。
非阻塞属性只能对于以下几种文件设置：
FIFO文件（管道和命名管道文件）
块设备文件（用于磁盘类设备 是字节数组，并且在给定位置读取的值是最后写入该位置的值）
字符设备文件（和输入/输出有关，用于串行 I/O 类设备）

- 你提到了管道，什么是管道？
管道是内核中的一个单向的数据通道，同时也是一个数据队列。具有一个读取端与一个写入端，只有有共同父进程的进程之间才可以用管道连接。

- 你提到了特殊文件，那么请大致说一下Linux的文件系统
Linux的文件包括常规文件，设备文件，目录文件
常规文件：包含有用户信息的文件 包括C语言元代码，Shell脚本，文本文件，图像文件，二进制的可执行文件可执行文件只有在文件格式正确的情况下才会执行。
设备文件：与系统外设相关的文件 包括块设备文件 
目录文件，是管理文件系统结构的系统文件

//这个地方我只是粗略的看一遍，到面试之前要再过几遍
- 请你说一下fork系统调用做了什么？
Linux平台通过clone()系统调用实现fork()。 fork()，vfork()和clone()库函数都根据各自需要的参数标志去调用clone()，然后由clone()去调用do_fork()， 再然后do_fork()完成了创建中的大部分工作，该函数调用copy_process().做最后的那部分工作
fork使用写时复制，高效创建子进程


- fork和vfork的区别
（1）fork：子进程拷贝父进程的代码段和数据段
vfork：子进程和父进程共享代码段和数据段
（2）fork中父子进程的先后运行次序不定
vfork：保证子进程先运行，子进程exit后父进程才开始被调度运行
（3） vfork （）保证子进程先运行，在她调用exec 或exit 之后父进程才可能被调度运行。如果在 调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。
（4）就算fork实现了写时拷贝，但其效率仍然没有vfork高，但是vfork在一般平台上都存在问题，所以一般不推荐使用

- 说一下exec系统调用
exec系统调用不返回

- 什么叫僵尸进程？如何处理？
子进程结束运行状态，父进程读取退出状态之前，或者父进程异常终止
调用wait等待子进程结束

- 请详细说一下wait系统调用
wait阻塞进程，直到某个子进程结束运行为止.返回子进程PID
因为wait阻塞进程导致效率较低，使用waitpid可以非阻塞等待，提高效率，waitpid可以给父进程发送信号通知

- semget()系统调用来说一下
这个系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集
参数是 键值、信号量的数量、信号量权限值
成功时返回标识符

- linux有什么系统调用能执行P、V操作？
semop系统调用
semop系统调用有参数：信号量集标识符，一个结构体，这个结构体指定了对信号量集中的具体信号量的操作，第三个数组制定了结构体操作的个数
semctl系统调用 能够对信号量直接进行调用


sem是一个系列的系统调用，能够创建各种信号量和操作

- 创建新的共享内存的系统调用是什么？
shmget系统调用。这个系统调用会把字节初始化为0.

- 共享内存怎么工作的？
需要使用shmat和shmdt两个系统调用来从进程地址中关联和分离。
进程地址设置为NULL将会由系统进行分配。

- 怎么样创建共享内存和释放关联？
mmap和munmap


- IPC方式有哪些？
消息队列，管道，共享内存

- 怎么在进程之间传递文件描述符？
使用UNIX域socket

- 说一下内核线程，用户线程，轻量级进程和协程
内核线程：
使用内核栈和和寄存器空间，但是调度成本高，等价于进程
内核线程就是内核的分身，一个分身可以处理一件特定事情。这在处理异步事件如异步IO时特别有用。内核线程的使用是廉价的，唯一使用的资源就是内核栈和上下文切换时保存寄存器的空间。支持多线程的内核叫做多线程内核。
轻量级进程（LWP）：
共用父进程的资源，调度同普通进程
轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。
用户线程：
与所属进程共享进程地址空间和系统资源，调度：由在用户空间实现的线程库，在所属进程内进行调度
用户线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁全又库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。

- 内核线程和用户线程有什么关系？
内核线程相当于用户线程运行的容器，当进程的一个内核线程获得CPU使用权的时候，加载并且运行一个用户线程
在一个系统的所有进程中，内核线程：用户线程（M:N）比例是不变的。

- 内核线程：用户线程，这个比例意味着什么？
这个比例决定了线程的实现方式，包括：完全在用户空间实现，完全由内核调度和双层调度
用户线程N永远大于等于内核线程M的数量
当N=1时，完全由线程库进行调度，内核不知道用户线程的存在，这时候不占用内核资源
优点是：创建和调度很快，不会对系统性能造成影响
缺点是：无法将一个进程的线程运行在多个CPU上，因为此时其内核最小调度单位是进程
M:N=1:1，此时用户空间线程全部被映射为内核线程
双层调度结合了前两种方式的优点。

- 线程如何回收？
一个进程中的所有线程都可以调用pthread_join函数来回收其它线程
可以使用pthread_cancel来异常终止一个线程

- 线程如何同步？
posix信号量，互斥量和条件变量。

- 子进程是否拥有和父进程相同数量的线程？
否。子进程只拥有一个执行线程，就是调用fork的那个线程的完整复制。
这个时候就会可能有子进程继承了父进程的一个非执行线程的互斥锁导致死锁的情况。
可以使用pthread_atfork来清除锁状态

- 谈一谈文件描述符？
0是标准输入，1是标准输出，2是标准错误。 posix规定每次打开新文件必须使用当前最小可用的描述符。


- kill进程的过程？
相比于kill -15命令，kill -9在执行时，应用程序是没有时间进行"准备工作"的，所以这通常会带来一些副作用，数据丢失或者终端无法恢复到正常状态等。
默认发送的信号是15，但是可能无法杀掉进程

- 消息队列内核实现原理


- 如何创建一个守护进程？
fork()子进程，父进程exit退出
子进程调用setsid创建新会话
再次fork
调用chdir，让/成为工作目录
设置进程文件权限掩码
在孙进程中关闭不需要的文件描述符


- 硬链接和软链接的区别
硬链接是指针，所有的硬链接都是指向同一个磁盘块。 删除一个指针不会真正删除文件，只有把所有的指针都删除才会真正删除文件。 软连接是另外一种类型的文件，保存的是它指向文件的全路径， 访问时会替换成绝对路径