- 线程同步应该遵循什么样的原则？
1. 尽量低限度的共享对象，减少需要同步的场合。有限暴露immutable对象
2. 其次使用高级并发结构，比如任务队列，生产者消费者队列，闭锁
3. 最后考虑使用底层同步原语，只使用非递归的互斥器和条件变量，慎用读写锁，不用信号量
4. 不自己编写lock-free代码，不使用内核级同步原语


- C++互斥器mutex是什么？如何实现的？
1. 互斥锁类是一个同步原语，可以用来保护共享数据不被多个线程同时访问。
互斥锁提供了互斥的、非递归的所有权语义:
调用线程拥有一个互斥锁，从它成功调用lock或try_lock，直到它调用unlock。
当一个线程拥有一个互斥锁时，如果其他线程试图声明对互斥锁的所有权，那么它们将阻塞(用于调用lock)或接收一个假返回值（try_lock）
2. 互斥锁都是判断并且置位一个标志位
这个操作必须是原子的
单核机器上可以通过关中断实现
多核机器上通过锁总线实现

- 为什么使用非递归的互斥器？递归的互斥器有什么问题？
非递归的互斥器容易定位问题

- 条件变量是什么？底层如何实现的？
条件变量是等待原语
和互斥器是并发的两个基础原语，互斥器意为互斥，条件变量意为等待
每个条件变量维护一个等待队列称之为 waitingThreads。在 wait 时，线程会把自己放进去，signal 时，会从 waitingThreads 里取出一个线程，放入全局的 readyQueue 里，交由操作系统唤醒。


- 什么叫临界区？
每个进程中访问临界资源的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个进程使用的共享资源）。

- 什么是lock-free？
多线程 共享内存 互相阻塞

- one loop per thread有什么好处？
线程数目固定，不会频繁创建与销毁
可以很方便的在线程间调配负载
IO事件发生的线程是固定的，同一个TCP连接不必考虑时间并发

- 如何处理没有IO而只有计算任务的线程？
使用blocking queue实现任务队列。

- 什么是rwlock？
读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。
读锁可重入，写锁不可重入。写锁优先，会阻塞后面的读锁。
使用读写锁会出现可重入锁有时死锁的问题，所以不推荐使用。
可以使用shared_ptr+COR+MUTEX替代读写锁

- 什么是CAS？什么是ABA问题？
CAS全称compare-and-swap，是计算机科学中一种实现多线程原子操作的指令，它比较内存中当前存在的值和外部给定的期望值，只有两者相等时，才将这个内存值修改为新的给定值。CAS操作包含三个操作数，需要读写的内存位置（V）、拟比较的预期原值（A）和拟写入的新值（B），如果V的值和A的值匹配，则将V的值更新为B，否则不做任何操作。多线程尝试使用CAS更新同一变量时，只有一个线程可以操作成功，其他的线程都会失败，失败的线程不会被挂起，只是在此次竞争中被告知失败，下次可以继续尝试CAS操作的。
ABA是改变之后无法知道是否被改变过的问题

- 什么是spin-lock？自旋锁
一种底层同步原语，同一时间只有一个进程可以获得锁，其它进程原地自旋，直到获得锁

- 使用mutex有什么原则？
不要使用递归的mutex，递归的mutex可能会失效导致调试出现问题

- 什么叫SC顺序一致性和CC缓存一致性？

- 什么是memory barrier？

- 什么是Acquire semantics？什么是Release semantics？
Acquire semantics从write-release操作中防止了内存重排序，保证读写在它后面
Release semantics保证读写操作都在它的前面进行
它们达到了memory barrier的隐式语义

- 什么叫False Sharing？
伪共享，多个线程访问一个缓存块导致互相缓存无效化，浪费大量时间。

- 如何避免伪共享?
避免两个变量落在一个缓冲行内，进行cache对齐

- 互斥器和条件变量分别用在什么条件下？
互斥器是加锁原语，条件变量是等待原语。
条件变量的学名是管程

- 条件变量使用应该遵循什么样的原则？
wait端：
1. 必须和mutex共同使用
2. mutex已经上锁才能调用wait
3. 判断和wait放入while循环中，判断之后再wait
signal端：
1. signal之前修改布尔条件
2. 修改布尔条件需要mutex保护
3. 区分signal和broadcast 前者表示资源可用，后者表示状态变化


- 为什么条件变量必须和mutex一起使用？
条件变量是原子的，但是while循环等待条件下的condition不是原子的



- 什么叫虚假唤醒？
wait可能在没有任何线程调用notify的情况下返回，这时候需要前置布尔条件while循环限制wait调用

- 什么叫DCL？
双重检查锁

- 什么是缓存一致性问题?如何解决呢?
当程序在运行过程中,会将运算需要的数据从主存复制一份到CPU 的高速缓存当中,那么 CPU 进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据,当运算结束之后,再将高速缓存中的数据刷新到主存当中。这个时候，在多核中运行的多线程就会因为高速缓存的不一致而造成缓存一致性问题。
为了解决缓存不一致性问题,通常来说有以下 2 种解决方法:
    1)通过在总线加 LOCK#锁的方式，保证同一时间只有一个CPU访问内存
    2)通过缓存一致性协议，将其它CPU中的缓存行置为无效

- 作为数据成员的mutex可以保护析构吗？
不可以，因为mutex成员的生命期最多和对象一样长


※ 信号量 条件变量 互斥量 这几个线程同步方式有什么区别？


