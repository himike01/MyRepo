- 说一下channel的结构 当channel阻塞时如何调度的？
buf 缓冲列表 （循环链表,和goroutine相互复制）
send index
recv index
lock 互斥锁
recvq 接收的协程队列
sendq 发送的协程队列

协程队列：sudog

当阻塞时，goroutine将会被抽象成含有G1指针和send元素的sudog结构体保存到hchan的sendq中等待被唤醒


- 说一下java和go中的逃逸分析？它们的逃逸分析分别在哪一个阶段进行的，为什么？
java的逃逸分析只存在jit的即时编译中，判断的依据是：对象被赋值给堆中对象的字段和类的静态变量或者对象被传递给了不确定的代码中运行
静态变量是逃逸的，堆中实例是逃逸的
如果不发生逃逸，那么编译器可以使用逃逸分析的结果做一些代码优化：
将堆转换为栈分配，如果某个对象在子程序中被分配（且不会逃逸），那么就会降低垃圾收集器运行的频率；同步消除；分离对象或标量替换（不需要要求该对象是一个连续的内存结构，那么该对象的部分可以不存储在内存）

java的逃逸时分析只能在运行时进行，因为java并不像Android那样有dex文件，可以以dex作为一个编译单元然后进行编译优化。
java是分离编译+静态加载的，因此逃逸分析不能在编译时进行。

go则是在编译期进行
发生逃逸的情况如下：
1. new或者字面量创建出的变量，将其指针作为函数返回值
2. 被已经逃逸的变量引用的指针
3. 被指针类型slice、map和chan引用的指针，一定发生逃逸

- 说一下go的内存分配策略
内存分配策略包括线性内存分配策略和空闲链表分配器
go采用空闲链表的分配策略，采用隔离适应的方式进行
golang分级分配，使用多级缓存根据对象大小进行分配，运行时根据对象的大小将对象分为微对象、小对象和大对象三种
微对象0-16b
小对象16b-32kb
大对象32kb-∞

管理内存的对象同样分为三级：
线程缓存、中心缓存、页堆缓存三个组件

堆区的线性内存 分为以下几个部分：
spans 指向内存管理单元的指针
bitmap 用于标识arena区域中哪些地址保存了对象
arena 是真正的堆区，8kb一页，存储了所有在堆上初始化的对象

对于任意一个地址，通过arena的基地址计算其页数并通过spans数组获得该片内存的管理单元runtime.mspan

- golang的地址空间如何分类？
分为以下四类：None，Reserved，Prepared，Ready
从这里看出go是强类型的



